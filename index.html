require('dotenv').config();
const express = require('express');
const fs = require('fs');
const path = require('path');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const Database = require('better-sqlite3');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3001;

/* ---------- PATHS / ROOTS ---------- */
/*
   DECK_ROOT      root folder you're hosting from (ex: /home/deck)
   HOME_DIR       where dashboard/landing/status/docs html live
   WEBSITES_PATH  where published sites live (/website/*.html)
   MOVIES_PATH    where video/audio lives
   DATABASE_ROOT  where ALL public DB data lives now

   NEW: DATABASE_ROOT/<apiKey>/<collection>.json
*/
const DECK_ROOT     = process.env.DECK_ROOT     || path.resolve(__dirname, '..');      // /home/deck
const HOME_DIR      = process.env.HOME_DIR      || path.join(DECK_ROOT, 'home');       // /home/deck/home
const HOME_FILE     = path.join(HOME_DIR, 'home.html');
const LANDING_FILE  = path.join(HOME_DIR, 'landing.html');
const STATUS_FILE   = path.join(HOME_DIR, 'status.html');
const WEBSITES_PATH = process.env.WEBSITES_PATH || path.join(DECK_ROOT, 'websites');   // /home/deck/websites
const MOVIES_PATH   = process.env.MOVIES_PATH   || process.env.MEDIA_PATH || path.join(DECK_ROOT, 'movies');

// all realtime/public DB data goes here
const DATABASE_ROOT = process.env.DATABASE_ROOT || path.join(DECK_ROOT, 'database');   // /home/deck/database

// ensure dirs exist
for (const p of [WEBSITES_PATH, MOVIES_PATH, HOME_DIR, DATABASE_ROOT]) {
  try { fs.mkdirSync(p, { recursive: true }); } catch {}
}

/* ---------- SQLITE DB for AUTH + SITES INDEX ---------- */
const DB_FILE = process.env.DB_FILE || path.join(DECK_ROOT, 'secure', 'buzzcloud.db');
try { fs.mkdirSync(path.dirname(DB_FILE), { recursive: true }); } catch {}

const db = new Database(DB_FILE);
db.pragma('journal_mode = WAL');
db.pragma('synchronous = NORMAL');

db.exec(`
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at INTEGER NOT NULL
);
CREATE TABLE IF NOT EXISTS sites (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  owner_id INTEGER NOT NULL,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  url TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (owner_id) REFERENCES users(id)
);
`);

try {
  db.exec(`CREATE UNIQUE INDEX IF NOT EXISTS idx_sites_name_nocase ON sites(name COLLATE NOCASE);`);
} catch (e) {
  console.warn('[BuzzCloud] Could not create unique index on sites.name; runtime checks will still prevent duplicates.');
}

const q = {
  userByEmail:    db.prepare('SELECT * FROM users WHERE email = ?'),
  userById:       db.prepare('SELECT id, email, name, created_at FROM users WHERE id = ?'),
  createUser:     db.prepare('INSERT INTO users (email, password_hash, name, created_at) VALUES (?,?,?,?)'),
  listSites:      db.prepare('SELECT id, name, slug, url, updated_at FROM sites WHERE owner_id = ? ORDER BY updated_at DESC'),
  getSite:        db.prepare('SELECT * FROM sites WHERE id = ?'),
  getSiteBySlug:  db.prepare('SELECT * FROM sites WHERE slug = ?'),
  getSiteByName:  db.prepare('SELECT * FROM sites WHERE lower(name) = lower(?)'),
  createSite:     db.prepare('INSERT INTO sites (owner_id, name, slug, url, created_at, updated_at) VALUES (?,?,?,?,?,?)'),
  updateSite:     db.prepare('UPDATE sites SET name = ?, slug = ?, url = ?, updated_at = ? WHERE id = ?'),
  deleteSite:     db.prepare('DELETE FROM sites WHERE id = ?')
};

/* ---------- APP MIDDLEWARE ---------- */
app.use(cors());
app.use(express.json({ limit: '5mb' }));
app.use(cookieParser());

/* ---------- AUTH HELPERS (for dashboard/console stuff like /api/sites) ---------- */
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-change-me';
const SECURE_COOKIES = String(process.env.SECURE_COOKIES || 'false').toLowerCase() === 'true';
const COOKIE_NAME = 'bc_token';

function setAuthCookie(res, token) {
  res.cookie(COOKIE_NAME, token, {
    httpOnly: true,
    sameSite: 'lax',
    secure: SECURE_COOKIES,
    maxAge: 7 * 24 * 3600 * 1000,
    path: '/'
  });
}
function clearAuthCookie(res){
  res.clearCookie(COOKIE_NAME, { path: '/' });
}
function issueToken(user) {
  return jwt.sign(
    { uid: user.id, email: user.email, name: user.name },
    JWT_SECRET,
    { expiresIn: '7d' }
  );
}
function requireAuth(req, res, next) {
  const bearer = (req.headers.authorization || '').startsWith('Bearer ')
    ? req.headers.authorization.slice(7)
    : null;
  const token = req.cookies[COOKIE_NAME] || bearer;
  if (!token) return res.status(401).json({ error: 'Not authenticated' });
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = { id: payload.uid, email: payload.email, name: payload.name };
    next();
  } catch {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

/* ---------- GENERAL HELPERS ---------- */
function safeJoin(root, p) {
  const resolved = path.join(root, p);
  const rootAbs = path.resolve(root);
  const resAbs  = path.resolve(resolved);
  if (!resAbs.startsWith(rootAbs)) return null;
  return resolved;
}
function guessType(filename) {
  const ext = path.extname(filename).toLowerCase();
  if (ext === '.html' || ext === '.htm') return 'text/html; charset=utf-8';
  if (ext === '.css')  return 'text/css; charset=utf-8';
  if (ext === '.js')   return 'application/javascript; charset=utf-8';
  if (ext === '.json') return 'application/json; charset=utf-8';
  if (ext === '.svg')  return 'image/svg+xml';
  if (ext === '.png')  return 'image/png';
  if (ext === '.jpg' || ext === '.jpeg') return 'image/jpeg';
  if (ext === '.gif')  return 'image/gif';
  if (ext === '.webp') return 'image/webp';
  if (ext === '.ico')  return 'image/x-icon';
  if (ext === '.mp4')  return 'video/mp4';
  if (ext === '.webm') return 'video/webm';
  if (ext === '.mkv')  return 'video/x-matroska';
  if (ext === '.mp3')  return 'audio/mpeg';
  if (ext === '.m4a')  return 'audio/mp4';
  if (ext === '.wav')  return 'audio/wav';
  if (ext === '.flac') return 'audio/flac';
  return 'application/octet-stream';
}
function sanitizeSlug(s){
  s = (s||'').toLowerCase().trim();
  return /^[a-z0-9-]{1,48}$/.test(s) ? s : null;
}
function sitePath(slug){
  const nice = sanitizeSlug(slug);
  return nice ? path.join(WEBSITES_PATH, `${nice}.html`) : null;
}
function ensureDir(p){
  try { fs.mkdirSync(p, { recursive: true }); } catch {}
}
function atomicWrite(filePath, data){
  const tmp = `${filePath}.${process.pid}.${Date.now()}.tmp`;
  fs.writeFileSync(tmp, data);
  fs.renameSync(tmp, filePath);
}

/* =============================================================================
   PUBLIC REALTIME DATABASE (multi-key version)
   =============================================================================

   - EVERY key is allowed. The "key" IS the namespace.
   - We store collections per key on disk like:

       DATABASE_ROOT/<apiKey>/<collection>.json

     Each file looks like:
       {
         "items": [
           { id, ...payload, created_at, updated_at },
           ...
         ]
       }

   SO:
   - Anyone can choose any apiKey string and start using it.
   - "Init / Create" in database.html just does a POST with that key.
   - That will create the folder/database file on disk.
   - After that, GET/PUT/DELETE/SSE using that same key will work.

   SECURITY NOTE:
     This is intentionally wide open. Anyone who knows a key can read/write
     that key's collections. Do not store secrets.
*/

/* --- sanitize apiKey & collection to safe folder/filenames --- */
function sanitizeKey(str){
  return String(str || '')
    .replace(/[^a-zA-Z0-9_\-]/g, '_')
    .slice(0,64) || 'default_key';
}
function sanitizeCollection(str){
  return String(str || '')
    .replace(/[^a-zA-Z0-9_\-]/g, '_')
    .slice(0,64) || 'default';
}

/* Get the absolute path for a given key+collection json file */
function collPath(key, collection){
  const safeKey  = sanitizeKey(key);
  const safeColl = sanitizeCollection(collection);
  return path.join(DATABASE_ROOT, safeKey, `${safeColl}.json`);
}

/* read collection file, return {items:[]} if missing or broken */
function readColl(key, collection){
  const p = collPath(key, collection);
  if (!fs.existsSync(p)) return { items: [] };
  try {
    return JSON.parse(fs.readFileSync(p, 'utf8'));
  } catch {
    return { items: [] };
  }
}

/* write collection file (creating folders if needed), then notify SSE */
function writeColl(key, collection, data){
  const p = collPath(key, collection);
  ensureDir(path.dirname(p));
  atomicWrite(p, JSON.stringify(data, null, 2));
  emitRealtime(key, collection, { type: 'update', at: Date.now() });
}

/* make an id for new items */
function newId(){
  return crypto.randomBytes(8).toString('hex');
}

/* REQUIRE that ?key= or header x-bc-key is present.
   We don't check correctness against some master key anymore.
   The key IS your namespace.
*/
function extractApiKey(req){
  const fromQuery  = req.query.key;
  const fromHeader = req.headers['x-bc-key'];
  const supplied   = fromQuery || fromHeader;
  if (!supplied) return null;
  return supplied;
}

/* ---------- HEALTH ---------- */

app.get('/ping', (_req, res) => res.send('pong'));

app.get('/api/health/db', (req, res) => {
  try {
    const one = db.prepare('SELECT 1 as ok').get();
    const users = db.prepare('SELECT COUNT(*) AS n FROM users').get();
    const haveFsDb = fs.existsSync(DATABASE_ROOT);
    return res.json({
      ok: !!one.ok && !!haveFsDb,
      engine: 'sqlite3+fs',
      sqliteFile: DB_FILE,
      fsRoot: DATABASE_ROOT,
      users: users.n
    });
  } catch (e) {
    return res.status(500).json({ ok: false, error: String(e.message || e) });
  }
});

app.get('/api/health/realtime', (_req, res) => {
  const ok = fs.existsSync(DATABASE_ROOT);
  return res.json({ ok, configured: ok });
});

/* ---------- AUTH (for dashboard console like /api/sites) ---------- */

app.post('/api/auth/signup', (req, res) => {
  const { email, password, name } = req.body || {};
  if (!email || !password || !name) {
    return res.status(400).json({ error: 'name, email, password required' });
  }
  if (!/^\S+@\S+\.\S+$/.test(email)) {
    return res.status(400).json({ error: 'invalid email' });
  }
  if (String(password).length < 8) {
    return res.status(400).json({ error: 'password must be at least 8 chars' });
  }

  try {
    if (q.userByEmail.get(email)) {
      return res.status(409).json({ error: 'email already in use' });
    }
    const hash = bcrypt.hashSync(String(password), 12);
    const now  = Date.now();
    const info = q.createUser.run(email, hash, String(name), now);
    const user = q.userById.get(info.lastInsertRowid);

    const token = issueToken(user);
    setAuthCookie(res, token);
    res.json({ id: user.id, email: user.email, name: user.name });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.post('/api/auth/login', (req, res) => {
  const { email, password } = req.body || {};
  if (!email || !password) {
    return res.status(400).json({ error: 'email, password required' });
  }
  try {
    const u = q.userByEmail.get(email);
    if (!u) return res.status(401).json({ error: 'invalid credentials' });
    if (!bcrypt.compareSync(String(password), u.password_hash)) {
      return res.status(401).json({ error: 'invalid credentials' });
    }
    const user = { id: u.id, email: u.email, name: u.name };
    const token = issueToken(user);
    setAuthCookie(res, token);
    res.json(user);
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.post('/api/auth/logout', (_req, res) => {
  clearAuthCookie(res);
  res.json({ ok: true });
});

app.get('/api/auth/me', requireAuth, (req, res) => {
  res.json({ id: req.user.id, email: req.user.email, name: req.user.name });
});

/* ---------- SITES API (dashboard projects) ---------- */

app.get('/api/sites', requireAuth, (req, res) => {
  try {
    res.json({ items: q.listSites.all(req.user.id) });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.get('/api/sites/:id', requireAuth, (req, res) => {
  try {
    const s = q.getSite.get(req.params.id);
    if (!s) return res.status(404).json({ error: 'Not found' });
    if (s.owner_id !== req.user.id) return res.status(403).json({ error: 'Forbidden' });

    let content = '';
    try {
      content = fs.readFileSync(sitePath(s.slug), 'utf8');
    } catch {}
    res.json({ id: s.id, name: s.name, slug: s.slug, url: s.url, content });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.post('/api/sites', requireAuth, (req, res) => {
  try {
    const { name, slug, content } = req.body || {};
    const nice = sanitizeSlug(slug);
    if (!name || !nice || !content) {
      return res.status(400).json({ error: 'name, slug, content required' });
    }

    // reject duplicate name globally (case-insensitive)
    const dupName = q.getSiteByName.get(String(name));
    if (dupName) {
      return res.status(409).json({ error: 'A site with this name already exists' });
    }

    if (q.getSiteBySlug.get(nice)) {
      return res.status(409).json({ error: 'Slug already exists' });
    }

    fs.writeFileSync(sitePath(nice), String(content));
    const url = `/website/${nice}.html`;
    const now = Date.now();

    const info = q.createSite.run(
      req.user.id,
      String(name),
      nice,
      url,
      now,
      now
    );

    res.json({
      id: info.lastInsertRowid,
      name,
      slug: nice,
      url,
      updatedAt: now
    });
  } catch (e) {
    if (
      String(e.message || '').includes('UNIQUE') &&
      String(e.message).includes('idx_sites_name_nocase')
    ) {
      return res.status(409).json({ error: 'A site with this name already exists' });
    }
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.put('/api/sites/:id', requireAuth, (req, res) => {
  try {
    const { name, slug, content } = req.body || {};
    const s = q.getSite.get(req.params.id);
    if (!s) return res.status(404).json({ error: 'Not found' });
    if (s.owner_id !== req.user.id) return res.status(403).json({ error: 'Forbidden' });

    let curSlug = s.slug;
    let newSlug = s.slug;
    let newUrl  = s.url;

    if (slug && slug !== s.slug) {
      const nice = sanitizeSlug(slug);
      if (!nice) return res.status(400).json({ error: 'Invalid slug' });

      const dup = q.getSiteBySlug.get(nice);
      if (dup && dup.id !== s.id) {
        return res.status(409).json({ error: 'Slug already in use' });
      }

      const oldPath = sitePath(s.slug);
      const newPath = sitePath(nice);
      try {
        if (fs.existsSync(oldPath)) fs.renameSync(oldPath, newPath);
      } catch (err) {
        console.error('rename error', err);
      }
      newSlug = nice;
      newUrl  = `/website/${nice}.html`;
      curSlug = nice;
    }

    let finalName = s.name;
    if (typeof name === 'string' && name.trim() && name.trim() !== s.name) {
      const dupName = q.getSiteByName.get(String(name));
      if (dupName && dupName.id !== s.id) {
        return res.status(409).json({ error: 'A site with this name already exists' });
      }
      finalName = String(name);
    }

    if (typeof content === 'string') {
      fs.writeFileSync(sitePath(curSlug), String(content));
    }

    const now = Date.Now?.() || Date.now();
    q.updateSite.run(finalName, newSlug, newUrl, now, s.id);

    res.json({
      id: s.id,
      name: finalName,
      slug: newSlug,
      url: newUrl,
      updatedAt: now
    });
  } catch (e) {
    if (
      String(e.message || '').includes('UNIQUE') &&
      String(e.message).includes('idx_sites_name_nocase')
    ) {
      return res.status(409).json({ error: 'A site with this name already exists' });
    }
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.delete('/api/sites/:id', requireAuth, (req, res) => {
  try {
    const s = q.getSite.get(req.params.id);
    if (!s) return res.status(404).json({ error: 'Not found' });
    if (s.owner_id !== req.user.id) return res.status(403).json({ error: 'Forbidden' });

    try { fs.unlinkSync(sitePath(s.slug)); } catch {}
    q.deleteSite.run(s.id);
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

/* ---------- PUBLIC DATABASE ROUTES (multi-key) ----------
   GET    /api/db/:collection?key=<apiKey>
           -> { items: [...] }

   POST   /api/db/:collection?key=<apiKey>
           body: { ...fields }
           -> created item {id,...,created_at,updated_at}

           This ALSO auto-creates the database file & folder if it doesn't exist.

   PUT    /api/db/:collection/:id?key=<apiKey>
           body: partial update
           -> updated item

   DELETE /api/db/:collection/:id?key=<apiKey>
           -> { ok:true }

   <apiKey> is the namespace.
*/
app.get('/api/db/:collection', (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) return res.status(401).json({ error:'Unauthorized (missing key)' });

  try {
    const coll = req.params.collection;
    const data = readColl(apiKey, coll);
    res.json({ items: data.items || [] });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.post('/api/db/:collection', (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) return res.status(401).json({ error:'Unauthorized (missing key)' });

  try {
    const coll = req.params.collection;
    const data = readColl(apiKey, coll);

    const body = req.body || {};
    const now  = Date.now();
    const item = {
      id: newId(),
      ...body,
      created_at: now,
      updated_at: now
    };

    data.items = Array.isArray(data.items) ? data.items : [];
    data.items.unshift(item);

    writeColl(apiKey, coll, data);
    res.json(item);
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.put('/api/db/:collection/:id', (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) return res.status(401).json({ error:'Unauthorized (missing key)' });

  try {
    const coll = req.params.collection;
    const id   = req.params.id;
    const data = readColl(apiKey, coll);

    const idx = (data.items || []).findIndex(x => String(x.id) === String(id));
    if (idx < 0) {
      return res.status(404).json({ error: 'Not found' });
    }

    const now = Date.now();
    data.items[idx] = {
      ...data.items[idx],
      ...req.body,
      id: data.items[idx].id,
      updated_at: now
    };

    writeColl(apiKey, coll, data);
    res.json(data.items[idx]);
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.delete('/api/db/:collection/:id', (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) return res.status(401).json({ error:'Unauthorized (missing key)' });

  try {
    const coll = req.params.collection;
    const id   = req.params.id;
    const data = readColl(apiKey, coll);

    const before = data.items?.length || 0;
    data.items = (data.items || []).filter(x => String(x.id) !== String(id));
    if (data.items.length === before) {
      return res.status(404).json({ error: 'Not found' });
    }

    writeColl(apiKey, coll, data);
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

/* ---------- REALTIME SSE (multi-key) ----------
   GET /api/rt/subscribe?collection=<collection>&key=<apiKey>

   - We keep subscriptions per (apiKey, collectionName)
   - "collection=*" means "all collections in this apiKey"
*/
const subscribers = new Map();
// key format: "<apiKey>::<collectionName>" or "<apiKey>::*"
// value: Set(res)

function subKey(apiKey, collection){
  return sanitizeKey(apiKey) + '::' + (collection || '*');
}
function addSubscriber(apiKey, collection, res){
  const k = subKey(apiKey, collection);
  if (!subscribers.has(k)) subscribers.set(k, new Set());
  subscribers.get(k).add(res);
}
function removeSubscriber(apiKey, collection, res){
  const k = subKey(apiKey, collection);
  const set = subscribers.get(k);
  if (!set) return;
  set.delete(res);
  if (set.size === 0) subscribers.delete(k);
}

/* broadcast updates:
   notify "<apiKey>::<collection>" and "<apiKey>::*"
*/
function emitRealtime(apiKey, collection, payload){
  const msgObj = { collection, ...payload };
  const msg = `data: ${JSON.stringify(msgObj)}\n\n`;

  const targets = [
    subKey(apiKey, collection),
    subKey(apiKey, '*')
  ];
  for (const t of targets){
    const set = subscribers.get(t);
    if (!set) continue;
    for (const res of set){
      try { res.write(msg); } catch {}
    }
  }
}

app.get('/api/rt/subscribe', (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) return res.status(401).json({ error:'Unauthorized (missing key)' });

  const collection = String(req.query.collection || '*');

  // SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders?.();

  addSubscriber(apiKey, collection, res);

  // hello
  res.write(
    `event: hello\n` +
    `data: ${JSON.stringify({ apiKey, collection })}\n\n`
  );

  // snapshot of just that collection if not "*"
  if (collection !== '*') {
    const snap = readColl(apiKey, collection);
    res.write(
      `event: snapshot\n` +
      `data: ${JSON.stringify({ collection, items: snap.items || [] })}\n\n`
    );
  }

  req.on('close', () => {
    removeSubscriber(apiKey, collection, res);
  });
});

/* ---------- MEDIA BROWSING / STREAMING ---------- */
app.get('/movies', (_req, res) => {
  try {
    const files = fs.existsSync(MOVIES_PATH)
      ? fs.readdirSync(MOVIES_PATH)
      : [];
    const exts = new Set([
      '.mp4','.webm','.mkv',
      '.mp3','.m4a','.wav','.flac'
    ]);
    const items = files
      .filter(f => exts.has(path.extname(f).toLowerCase()))
      .map(filename => ({
        filename,
        url: `/stream/${encodeURIComponent(filename)}`
      }));
    res.json(items);
  } catch {
    res.status(500).json({ error: 'Unable to list media' });
  }
});

// player helper
app.get('/page/:basename', (req, res) => {
  const base = req.params.basename;
  const htmlPath = safeJoin(MOVIES_PATH, `${base}.html`);
  if (htmlPath && fs.existsSync(htmlPath)) {
    return res.sendFile(path.resolve(htmlPath));
  }

  const candidates = fs.existsSync(MOVIES_PATH)
    ? fs.readdirSync(MOVIES_PATH).filter(f => path.parse(f).name === base)
    : [];
  if (!candidates.length) return res.status(404).send('Not found');

  const file = candidates[0];
  const type = guessType(file);
  const tag  = type.startsWith('video/') ? 'video' : 'audio';
  const title = `${base} (${type})`;

  const html = `<!doctype html>
<html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>${title}</title>
<style>
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  background:#0b1220;
  color:#e8f0ff;
  display:grid;
  min-height:100vh;
  place-items:center
}
.wrap{
  max-width:960px;
  width:92%;
  margin:40px auto;
  text-align:center
}
h1{
  font-size:1.2rem;
  margin-bottom:12px
}
.player{
  background:#121a35;
  border:1px solid rgba(255,255,255,.08);
  border-radius:12px;
  padding:16px
}
${tag}{
  width:100%;
  max-height:70vh;
  background:#000;
  border-radius:8px;
  outline:none
}
a{color:#9ec2ff}
</style>
</head>
<body>
  <div class="wrap">
    <h1>${title}</h1>
    <div class="player">
      <${tag} controls preload="metadata"
        src="/stream/${encodeURIComponent(file)}"></${tag}>
    </div>
    <p style="opacity:.8;margin-top:10px">
      Serving fallback viewer (no custom HTML file found).
    </p>
  </div>
</body></html>`;

  res.type('html').send(html);
});

// byte-range streaming
app.get('/stream/:filename', (req, res) => {
  const decoded = decodeURIComponent(req.params.filename);
  const filePath = safeJoin(MOVIES_PATH, decoded);
  if (!filePath || !fs.existsSync(filePath)) {
    return res.status(404).send('Not found');
  }

  const stat  = fs.statSync(filePath);
  const total = stat.size;
  const type  = guessType(filePath);

  if (req.headers.range) {
    const m = req.headers.range.match(/bytes=(\d*)-(\d*)/);
    if (!m) return res.status(416).send('Malformed Range');
    const start = m[1] ? parseInt(m[1], 10) : 0;
    const end   = m[2] ? parseInt(m[2], 10) : total - 1;
    if (start >= total || end >= total) {
      return res.status(416).send('Range Not Satisfiable');
    }

    const chunkSize = (end - start) + 1;
    res.writeHead(206, {
      'Content-Range': `bytes ${start}-${end}/${total}`,
      'Accept-Ranges': 'bytes',
      'Content-Length': chunkSize,
      'Content-Type': type
    });
    fs.createReadStream(filePath, { start, end }).pipe(res);
  } else {
    res.writeHead(200, {
      'Content-Length': total,
      'Accept-Ranges': 'bytes',
      'Content-Type': type
    });
    fs.createReadStream(filePath).pipe(res);
  }
});

/* ---------- STATIC ROUTES ---------- */
app.use('/website', express.static(WEBSITES_PATH));
app.use('/home', express.static(HOME_DIR));

app.get(['/home', '/home/'], (_req,res) => {
  if (!fs.existsSync(HOME_FILE)) {
    return res.status(404).send('home.html not found in /home folder');
  }
  res.type('text/html; charset=utf-8');
  return res.sendFile(path.resolve(HOME_FILE));
});

app.get(['/website', '/website/'], (_req,res) => {
  for (const f of ['index.html', 'home.html']) {
    const p = safeJoin(WEBSITES_PATH, f);
    if (p && fs.existsSync(p)) {
      return res.sendFile(path.resolve(p));
    }
  }
  return res.status(404).send(`No default website file (index.html or home.html) in ${WEBSITES_PATH}`);
});

app.get(['/status', '/status/'], (_req,res) => {
  if (!fs.existsSync(STATUS_FILE)) {
    return res.status(404).send('status.html not found in /home folder');
  }
  res.type('text/html; charset=utf-8');
  return res.sendFile(path.resolve(STATUS_FILE));
});

app.get('/', (_req, res) => {
  if (!fs.existsSync(LANDING_FILE)) {
    return res.status(404).send('landing.html not found in /home folder');
  }
  res.type('text/html; charset=utf-8');
  return res.sendFile(path.resolve(LANDING_FILE));
});

/* ---------- START SERVER ---------- */
app.listen(PORT, () => {
  console.log(`BuzzCloud server listening on port ${PORT}`);
  console.log(`DECK_ROOT:     ${DECK_ROOT}`);
  console.log(`HOME_DIR:      ${HOME_DIR}`);
  console.log(`WEBSITES_DIR:  ${WEBSITES_PATH}`);
  console.log(`DATABASE_ROOT: ${DATABASE_ROOT}`);
  console.log(`MOVIES_PATH:   ${MOVIES_PATH}`);
  console.log(`Try root:      http://localhost:${PORT}/`);
  console.log(`Try /home:     http://localhost:${PORT}/home/`);
  console.log(`Status:        http://localhost:${PORT}/status`);
  console.log(`Example DB:    GET /api/db/chat_global?key=myKey123`);
  console.log(`Example SSE:   /api/rt/subscribe?collection=chat_global&key=myKey123`);
});
